#include <stdint.h>     // для int64 либо int32
#include <stdlib.h>     //для генерации псевдосэплов. В версии для прибора УДАЛИТЬ
#include <math.h>		// для sqrt (??)
#include <stdio.h>      // для вывода на в консоль. В версии для приобора УДАЛИТЬ

//посылает выходной сигнал на монитор либо цифровой выход (было бы здорово посмотреть на оба примера)
void send(int64_t);

//загружает с компьютера параметры фильтрации в виде 1 массива
int64_t *load_coef();

//функция, откуда берется новый сэмпл (либо какая-то структура которая его хранит)
int32_t receive_sample();

//функция для генерации сэмплов из гауссовского распределения
int32_t gauss(int8_t, int32_t);



static int32_t state1 = 0; //УБРАТЬ в версии c реальными данными
static int32_t state2 = 0; //УБРАТЬ в версии c реальными данными
static int32_t process = 0; //УБРАТЬ в версии c реальными данными
	

//частота дискретизации - 1000 Гц

// in_signal - 32 bit (32 bit ADC??)
//filter_coef - 24 bit
// all calculations in signed 64 bit
void main()
{
	srand(0);  //УБРАТЬ в версии c реальными данными
	
	
	
	
	int64_t *filter_coef = load_coef(); // прием параметров фильтрации с компьютера
	
	const int64_t FILTER_LEN = 100;
	const int64_t SRATE = 1000;
	int64_t i = 0;
	int64_t in_signal[100] = {0};
	int64_t filtered1;
	int64_t filtered2;
	int64_t envelope;
	
	
	
	while(1)
	{
		for (i = FILTER_LEN-1; i>0; i--)
		{
			in_signal[i] = in_signal[i-1];
		}
		
		in_signal[0] = (int64_t)receive_sample();
		
		filtered1 = 0;
		filtered2 = 0;
		
		for (i = 0; i<FILTER_LEN; i++)
		{
			filtered1 += in_signal[i]*filter_coef[i];
			filtered2 += in_signal[i]*filter_coef[i+FILTER_LEN]; 
		}
		filtered1 /= 0xFFFFFFFF; // ~24 bit
		filtered2 /= 0xFFFFFFFF;
			
		
		envelope = sqrt(filtered1*filtered1+filtered2*filtered2)/filter_coef[FILTER_LEN*2]; // ~8 bit
		
		//посылаем огибающую на экран и на цифровой выход (на цифрровой выход можно просто всегда 1 пока выводить, на мониторе тоже можно
		// просто зажигать все пиксели, либо в количестве, равному значению envelope)
		send(envelope);
	}
}




// Вместо этой функции должен быть вывод на экран числа пикселей, равного значению 'envelope' (либо просто какой-то постоянный паттерн), 
// а также отправка "1" на цифровой выход
void send(int64_t envelope)
{
	printf("%d\n",envelope);
}

// Функция, которая с комьпьютера загружает любым способом параметры при инициализации (один раз, после загрузки скрипта)
int64_t *load_coef()
{
	static int64_t params[201] = {16777215,  16744108,  16644921,  16480044,  16250127,  15956079,
        15599060,  15180477,  14701985,  14165471,  13573052,  12927066,
        12230063,  11484793,  10694199,   9861399,   8989681,   8082484,
         7143390,   6176104,   5184444,   4172323,   3143736,   2102742,
         1053450,         0,  -1053450,  -2102742,  -3143736,  -4172323,
        -5184444,  -6176104,  -7143390,  -8082484,  -8989681,  -9861399,
       -10694199, -11484793, -12230063, -12927066, -13573052, -14165471,
       -14701985, -15180477, -15599060, -15956079, -16250127, -16480044,
       -16644921, -16744108, -16777215, -16744108, -16644921, -16480044,
       -16250127, -15956079, -15599060, -15180477, -14701985, -14165471,
       -13573052, -12927066, -12230063, -11484793, -10694199,  -9861399,
        -8989681,  -8082484,  -7143390,  -6176104,  -5184444,  -4172323,
        -3143736,  -2102742,  -1053450,         0,   1053450,   2102742,
         3143736,   4172323,   5184444,   6176104,   7143390,   8082484,
         8989681,   9861399,  10694199,  11484793,  12230063,  12927066,
        13573052,  14165471,  14701985,  15180477,  15599060,  15956079,
        16250127,  16480044,  16644921,  16744108,         0,   1053450,
         2102742,   3143736,   4172323,   5184444,   6176104,   7143390,
         8082484,   8989681,   9861399,  10694199,  11484793,  12230063,
        12927066,  13573052,  14165471,  14701985,  15180477,  15599060,
        15956079,  16250127,  16480044,  16644921,  16744108,  16777214,
        16744108,  16644921,  16480044,  16250127,  15956079,  15599060,
        15180477,  14701985,  14165471,  13573052,  12927066,  12230063,
        11484793,  10694199,   9861399,   8989681,   8082484,   7143390,
         6176104,   5184444,   4172323,   3143736,   2102742,   1053450,
               0,  -1053450,  -2102742,  -3143736,  -4172323,  -5184444,
        -6176104,  -7143390,  -8082484,  -8989681,  -9861399, -10694199,
       -11484793, -12230063, -12927066, -13573052, -14165471, -14701985,
       -15180477, -15599060, -15956079, -16250127, -16480044, -16644921,
       -16744108, -16777215, -16744108, -16644921, -16480044, -16250127,
       -15956079, -15599060, -15180477, -14701985, -14165471, -13573052,
       -12927066, -12230063, -11484793, -10694199,  -9861399,  -8989681,
        -8082484,  -7143390,  -6176104,  -5184444,  -4172323,  -3143736,
        -2102742,  -1053450, 0x20000};
	return params;
}

// функция, которая генерирует данные (альфа-ритм + c шумом)
int32_t receive_sample()
{
	state1 = 32703*state1+2057*state2 + gauss(16, 32);
	state2 = 32703*state2-2057*state1 + gauss(16, 32);
	process = state1 + gauss(16, 16);
}

//функция, которая генерирует сэмплы из гауссовского распределения
int32_t gauss(int8_t noise_level, int32_t divider) //noise level - не менее 8!!!
{ 
	int32_t cumsum = 0;
	for (int k = 0; k < noise_level; k++)
	{
		cumsum += (rand()%0x7FFF);
	}
	cumsum -= (noise_level*0x7FFF)/2;
	
	cumsum /= divider;
	return cumsum;
}
